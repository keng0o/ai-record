export interface User {
  displayName: string;
  email: string;
  photoURL: string;
}

export interface Session {
  id: string;
  threads: {
    main: Thread[];
  };
}

export interface Thread {
  content: [{ text: string }];
  role: "user" | "model" | "system";
  metadata: { preamble: boolean };
}

export interface Record {
  date: string;
  reply: string;
}
"use client";

import pixelmatch from "pixelmatch";
import { useCallback, useEffect, useRef, useState } from "react";

import { Chat } from "@/types";
import ChatSidebar from "./ChatSidebar";
import ChatWindow from "./ChatWindow";
// import { chatWithAI } from "@/app/actions";
import { postImage, postMessage } from "@/app/actions";
import { addRecord, createLocalSessionStore } from "@/utils/firestore";

const CAPTURE_CONFIG = {
  THRESHOLD: 0.1,
  MIN_DIFF_PERCENTAGE: 0.01,
} as const;

// ヘルパー関数: キャンバスから画像データを取得
function getCanvasImageData(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData | null {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// ヘルパー関数: メディアトラックを停止
function stopMediaTracks(video: HTMLVideoElement) {
  if (video.srcObject instanceof MediaStream) {
    video.srcObject.getTracks().forEach((track) => track.stop());
    video.srcObject = null;
  }
}

export default function ClientHome({
  sessions,
  uid,
}: {
  sessions: { date: string }[];
  uid: string;
}) {
  const [sessionId, setActiveChatId] = useState<string>();
  const [chats, setChats] = useState<Chat[]>([]);
  const [capturedImages, setCapturedImages] = useState<string[]>([]);

  const [capturing, setCapturing] = useState(false);
  const [paused, setPaused] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const previousImageDataRef = useRef<ImageData | null>(null);
  const store = createLocalSessionStore(uid);
  console.log("🚀 ~ store:", store);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      handleStopCapture();
    };
  }, []);

  /**
   * Compare two ImageData objects and check if there's a significant difference
   */
  const checkSignificantDiff = (
    oldData: ImageData | null,
    newData: ImageData
  ): boolean => {
    if (!oldData) return true;
    if (oldData.width !== newData.width || oldData.height !== newData.height)
      return true;

    const { width, height } = newData;
    const diffOutput = new Uint8Array(width * height * 4);
    const numDiffPixels = pixelmatch(
      oldData.data,
      newData.data,
      diffOutput,
      width,
      height,
      {
        threshold: CAPTURE_CONFIG.THRESHOLD,
        includeAA: true,
        alpha: 0.1,
        diffColor: [255, 0, 0],
      }
    );

    const totalPixels = width * height;
    const diffRatio = numDiffPixels / totalPixels;

    return diffRatio >= CAPTURE_CONFIG.MIN_DIFF_PERCENTAGE;
  };

  /**
   * Capture a single screenshot and post if there's a significant difference
   */
  const captureScreenshot = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      console.log("Video not ready yet...");
      return;
    }
    const newImageData = getCanvasImageData(video, canvas);
    if (!newImageData) return;

    if (checkSignificantDiff(previousImageDataRef.current, newImageData)) {
      const image = canvas.toDataURL("image/png");
      setCapturedImages((prev) => [...prev, image]);
      const result = await postImage({ image });
      console.log("Image posted:", result.reply);
      await addRecord(uid, {
        date: result.date.toISOString(),
        reply: result.reply,
      });
    } else {
      console.log("No significant difference detected. Skipping.");
    }
    previousImageDataRef.current = newImageData;
  }, [uid]);

  /**
   * Start repeated capture using setInterval
   */
  useEffect(() => {
    if (!capturing || !videoRef.current) return;

    const intervalId = setInterval(() => {
      if (paused) {
        console.log("Capture paused.");
        return;
      }
      captureScreenshot();
    }, 1000);

    return () => clearInterval(intervalId);
  }, [capturing, paused, captureScreenshot]);

  /**
   * Handle start capturing
   */
  const handleStartCapture = async () => {
    if (capturing) return;

    try {
      console.log("Requesting display media...");
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
      });

      // Reset before capturing
      setCapturedImages([]);
      previousImageDataRef.current = null;

      if (!videoRef.current) throw new Error("Video element not found");
      videoRef.current.srcObject = stream;
      await videoRef.current.play();

      setCapturing(true);
      setPaused(false);
    } catch (err) {
      console.error("Error starting capture:", err);
      alert("画面キャプチャの開始に失敗しました");
    }
  };

  const handleSessionChat = async () => {
    const newChat: Chat = {
      id: sessionId,
      messages: [],
    };
    setChats((prev) => [...prev, newChat]);
  };

  /**
   * Handle stop capturing
   */
  const handleStopCapture = async () => {
    console.log("Stopping capture...");
    setCapturing(false);
    setPaused(false);
    if (videoRef.current) {
      stopMediaTracks(videoRef.current);
    }
  };

  /**
   * Add a new message to a specific chat
   */
  const handleAddMessage = async (prompt: string) => {
    const response = await postMessage({
      uid,
      sessionId: sessionId,
      prompt,
    });
    console.log("🚀 ~ handleAddMessage ~ response:", response);
    setChats((prevChats) =>
      prevChats.map((chat) => {
        if (chat.id === sessionId) {
          // return { ...chat, messages: [...chat.messages, msg] };
        }
        return chat;
      })
    );
  };

  /**
   * Identify the active chat object
   */
  const activeChat = chats.find((c) => c.id === sessionId);

  return (
    <div className="flex h-full">
      <canvas ref={canvasRef} style={{ display: "none" }} />
      <video ref={videoRef} autoPlay style={{ display: "none" }} muted />

      {/* Sidebar */}
      <div className="w-64 bg-gray-200 p-4 space-y-2">
        {capturing ? (
          <>
            <button
              onClick={() => setPaused((prev) => !prev)}
              className="px-4 py-2 rounded bg-yellow-500 text-white w-full"
            >
              {paused ? "再開" : "一時停止"}
            </button>
            <button
              onClick={handleStopCapture}
              className="px-4 py-2 rounded bg-red-500 text-white w-full"
            >
              停止
            </button>
          </>
        ) : (
          <>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleSessionChat}
            >
              記録の振り返り
            </button>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleStartCapture}
            >
              記録を開始
            </button>
          </>
        )}

        <ChatSidebar
          sessions={sessions}
          sessionId={sessionId}
          setActiveChatId={setActiveChatId}
        />
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {activeChat ? (
          <ChatWindow onAddMessage={handleAddMessage} />
        ) : (
          <div className="flex-1 flex justify-center items-center">
            <p className="text-gray-500">
              チャットを選択、または作成してください
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
"use client";

import { useState } from "react";

interface Message {
  role: "user" | "ai";
  content: string;
  timestamp: string;
}

interface ChatWindowProps {
  onAddMessage: (prompt: string) => void;
}

// interface HistoryMessage {
//   role: "user" | "ai";
//   parts: { text: string }[];
// }

export default function ChatWindow({ onAddMessage }: ChatWindowProps) {
  const [userInput, setUserInput] = useState("");
  // const [chatHistory, setChatHistory] = useState<HistoryMessage[]>([]);

  const handleSend = async () => {
    if (!userInput.trim()) return;
    onAddMessage(userInput.trim());

    try {
      // const res = await fetch("/api/askQuestion", {
      //   method: "POST",
      //   headers: { "Content-Type": "application/json" },
      //   body: JSON.stringify({ chatId: chat.id, question: userInput }),
      // });
      // const data = await res.json();
      // const aiMsg: Message = {
      //   role: "ai",
      //   content: data.answer,
      //   timestamp: new Date().toISOString(),
      // };
      // onAddMessage(chat.id, aiMsg);
      // if (data.history) {
      //   setChatHistory(data.history);
      // }
    } catch (error) {
      console.error("Error in askQuestion:", error);
    }

    setUserInput("");
  };

  return (
    <div className="flex flex-col flex-1 p-4">
      {/* Messages */}
      <div className="flex-1 overflow-auto mb-4 border p-2">
        {/* {chat.messages.map((msg, i) => (
          <div key={i} className="mb-2">
            <div
              className={
                msg.role === "user" ? "text-blue-600" : "text-green-600"
              }
            >
              {msg.role === "user" ? "You" : "AI"}
            </div>
            <div>{msg.content}</div>
          </div>
        ))} */}

        {/* {chatHistory.map((msg, i) => (
          <div key={`history-${i}`} className="mb-2 text-gray-600">
            <div>{msg.role === "user" ? "You" : "AI"} (履歴)</div>
            <div>{msg.parts[0]?.text || ""}</div>
          </div>
        ))} */}
      </div>

      {/* Input Form */}
      <div className="flex">
        <input
          type="text"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") handleSend();
          }}
          className="border flex-1 px-2 py-1"
          placeholder="質問を入力..."
        />
        <button
          onClick={handleSend}
          className="bg-blue-500 text-white px-4 py-1 ml-2 rounded"
        >
          送信
        </button>
      </div>
    </div>
  );
}
"use client";

import { Session } from "@/types";

interface ChatSidebarProps {
  sessions: Session[];
  activeChatId: string | null;
  setActiveChatId: (id: string) => void;
}

export default function ChatSidebar({
  sessions,
  activeChatId,
  setActiveChatId,
}: ChatSidebarProps) {
  return (
    <div>
      {sessions.map((session, index) => (
        <div
          key={index}
          onClick={() => setActiveChatId(session.id)}
          className={`p-2 mb-2 cursor-pointer rounded ${
            session.id === activeChatId ? "bg-blue-300" : "bg-white"
          }`}
        >
          <div className="text-sm font-bold">
            sss
            {/* {session.createdAt.toISOString()} */}
          </div>
        </div>
      ))}
    </div>
  );
}
"use server";

import { ai } from "@/utils/aiConfig";
import { createLocalSessionStore } from "@/utils/localSessionStore";

import { getReords } from "@/utils/firestore";

export async function postImage({ image }: { image: string }) {
  const now = new Date();

  // 4) チャットを送信
  const chat = ai.chat();
  const prompt = `[指示]
スクリーンショットを添付します。

これらのスクリーンショットに写っている情報をすべて抽出し、以下の点に注意して、事実に基づいた詳細なレポートを作成してください。

1. 各スクリーンショットに写っている情報を網羅的に記述する。
2. 情報源（スクリーンショットのファイル名）を明記する。
3. 異なるスクリーンショットに同一の情報が記載されている場合は、重複を避けて簡潔にまとめる。
4. 情報が矛盾する場合は、それぞれの情報を併記し、矛盾点を指摘する。
5. 必要に応じて、情報の背景や意味合いを考察する。
6. 機密事項や個人情報が含まれる場合は、適切に伏せる。

  撮影日時: ${now.toLocaleDateString()}
  `.trim();

  const response = await chat.send([
    {
      media: {
        contentType: "image/png",
        url: image,
      },
    },
    { text: prompt },
  ]);

  return {
    reply: response.text,
    date: now,
  };
}

async function getSession(sessionId: string | undefined, uid: string) {
  const store = createLocalSessionStore(uid);
  if (sessionId) {
    const session = await ai.loadSession(sessionId, { store });
    return session;
  } else {
    const session = ai.createSession({
      store,
    });
    return session;
  }
}

async function getAIChat(sessionId: string | undefined, uid: string) {
  const records = await getReords(uid);
  const session = await getSession(sessionId, uid);
  if (sessionId) {
    return session.chat();
  } else {
    return session.chat({
      system: `私の過去の記録です。${JSON.stringify(records)}`,
    });
  }
}

export async function postMessage({
  uid,
  sessionId,
  prompt,
}: {
  uid: string;
  sessionId: string | undefined;
  prompt: string;
}) {
  const now = new Date();
  // 4) チャットを送信
  const session = await getSession(sessionId, uid);
  const sessionChat = await getAIChat(sessionId, uid);

  const response = await sessionChat.send(
    `あなたは、過去の時系列の日記データに基づいて、ユーザーの質問に答えるAIです。

## 日記データ
session情報をもとに

## 指示

1. ユーザーからの質問を受け取ります。
2. 質問内容を理解し、日記データの中から関連する情報を検索します。
3. 関連する情報に基づいて、質問に対する回答を生成します。
4. 回答は、事実に基づいた正確なものである必要があります。
5. 回答は、ユーザーにとって分かりやすく、丁寧な言葉遣いである必要があります。
6. 回答の中で、日記データからの引用を適切に行うようにしてください。
7. 質問内容によっては、複数の日記データを参照する必要がある場合があります。
8. 質問内容によっては、回答が困難な場合があります。その場合は、「この質問にはお答えできません」と回答してください。

## ユーザーからの質問
${prompt}
  `.trim()
  );

  return {
    reply: response.text,
    sessionId: session.id,
    date: now,
  };
}
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "AI Recorder",
  description: "Manage and analyze records using AI",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
"use client";

import { auth, googleAuthProvider } from "@/lib/firebase";
import { addUser } from "@/lib/firestore";
import { onAuthStateChanged, signInWithPopup } from "firebase/auth";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function JP() {
  const router = useRouter();

  // ログイン状態をチェックし、ログイン済みならリダイレクトする
  useEffect(() => {
    return onAuthStateChanged(auth, (user) => {
      if (user) {
        router.push("/");
      }
    });
  }, [router]);

  const signInWithGoogle = async () => {
    try {
      const { user } = await signInWithPopup(auth, googleAuthProvider);
      await addUser({
        uid: user.uid,
        email: user.email || "",
        displayName: user.displayName || "",
        photoURL: user.photoURL || "",
      });
    } catch (error) {
      console.error("Error during Google login", error);
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center p-4">
      <section className="mb-8 text-center">
        <h1 className="text-4xl font-bold mb-4">Welcome to AI Record</h1>
        <p className="text-lg">
          機能紹介: 当サービスはAIを活用した記録管理と分析を提供します。
        </p>
      </section>
      <section className="w-full max-w-md">
        <form className="flex flex-col space-y-4">
          <button
            type="button"
            className="bg-red-500 text-white py-2"
            onClick={signInWithGoogle}
          >
            Google Login
          </button>
        </form>
      </section>
    </div>
  );
}
"use client";

import pixelmatch from "pixelmatch";
import { useCallback, useEffect, useRef, useState } from "react";

import { postImage, postMessage } from "@/app/actions";
import { addRecord } from "@/lib/firestore";
import { createLocalSessionStore } from "@/lib/localSessionStore";
import { Session } from "@/types";

import SessionSidebar from "./SessionSidebar";
import SessionWindow from "./SessionWindow";

interface ClientHomeProps {
  sessions: { date: string }[];
  uid: string;
}

/** Configuration constants */
const CAPTURE_CONFIG = {
  THRESHOLD: 0.1,
  MIN_DIFF_PERCENTAGE: 0.01,
} as const;

/**
 * Helper: draw current frame from video to canvas and retrieve ImageData.
 */
function getCanvasImageData(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData | null {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

/**
 * Helper: stop all media tracks in the given video element.
 */
function stopMediaTracks(video: HTMLVideoElement) {
  if (video.srcObject instanceof MediaStream) {
    video.srcObject.getTracks().forEach((track) => track.stop());
    video.srcObject = null;
  }
}

/**
 * Main component that handles:
 * 1) Screen capture & difference checking.
 * 2) Session session creation and message handling.
 */
export default function ClientHome({ sessions, uid }: ClientHomeProps) {
  const [sessionId, setActiveSessionId] = useState<string>();
  const [Sessions, setSessions] = useState<Session[]>([]);
  const [capturedImages, setCapturedImages] = useState<string[]>([]);
  const [capturing, setCapturing] = useState(false);
  const [paused, setPaused] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const previousImageDataRef = useRef<ImageData | null>(null);

  // Example usage of a local session store if needed:
  const store = createLocalSessionStore(uid);

  /**
   * Cleanup on unmount: stop capture if still running.
   */
  useEffect(() => {
    return () => {
      handleStopCapture();
    };
  }, []);

  /**
   * Compare two ImageData objects and check if there's a significant difference.
   */
  const checkSignificantDiff = (
    oldData: ImageData | null,
    newData: ImageData
  ): boolean => {
    if (!oldData) return true;
    if (oldData.width !== newData.width || oldData.height !== newData.height) {
      return true;
    }

    const { width, height } = newData;
    const diffOutput = new Uint8Array(width * height * 4);
    const numDiffPixels = pixelmatch(
      oldData.data,
      newData.data,
      diffOutput,
      width,
      height,
      {
        threshold: CAPTURE_CONFIG.THRESHOLD,
        includeAA: true,
        alpha: 0.1,
        diffColor: [255, 0, 0],
      }
    );

    const totalPixels = width * height;
    const diffRatio = numDiffPixels / totalPixels;
    return diffRatio >= CAPTURE_CONFIG.MIN_DIFF_PERCENTAGE;
  };

  /**
   * Capture a single screenshot and, if there is a significant difference,
   * send it to the server for AI-based extraction.
   */
  const captureScreenshot = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;

    if (video.videoWidth === 0 || video.videoHeight === 0) {
      console.log("Video not ready yet...");
      return;
    }

    const newImageData = getCanvasImageData(video, canvas);
    if (!newImageData) return;

    if (checkSignificantDiff(previousImageDataRef.current, newImageData)) {
      const image = canvas.toDataURL("image/png");
      setCapturedImages((prev) => [...prev, image]);

      const result = await postImage({ image });
      await addRecord(uid, {
        date: result.date.toISOString(),
        reply: result.reply,
      });
    }
    previousImageDataRef.current = newImageData;
  }, [uid]);

  /**
   * Start repeated capture at a fixed interval.
   */
  useEffect(() => {
    if (!capturing || !videoRef.current) return;

    const intervalId = setInterval(() => {
      if (!paused) {
        void captureScreenshot();
      }
    }, 1000);

    return () => clearInterval(intervalId);
  }, [capturing, paused, captureScreenshot]);

  /**
   * Handle the start of a screen capture.
   */
  const handleStartCapture = async () => {
    if (capturing) return;
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
      });
      setCapturedImages([]);
      previousImageDataRef.current = null;

      if (!videoRef.current) {
        throw new Error("Video element not found");
      }
      videoRef.current.srcObject = stream;
      await videoRef.current.play();

      setCapturing(true);
      setPaused(false);
    } catch (err) {
      console.error("Error starting capture:", err);
      alert("画面キャプチャの開始に失敗しました");
    }
  };

  /**
   * Create a new blank Session or open "review" if there's no sessionId.
   */
  const handleSessionSession = () => {
    const newSession: Session = {
      id: sessionId || "new-session",
      messages: [],
    };
    setSessions((prev) => [...prev, newSession]);
  };

  /**
   * Stop capturing entirely.
   */
  const handleStopCapture = () => {
    setCapturing(false);
    setPaused(false);

    if (videoRef.current) {
      stopMediaTracks(videoRef.current);
    }
  };

  /**
   * Send a new user message to the AI.
   */
  const handleAddMessage = async (prompt: string) => {
    const response = await postMessage({
      uid,
      sessionId,
      prompt,
    });
    // Example: add to local Session state if needed
    setSessions((prevSessions) =>
      prevSessions.map((Session) => {
        if (Session.id === sessionId) {
          const newMessages = [
            ...Session.messages,
            { role: "user", content: prompt },
            { role: "ai", content: response.reply },
          ];
          return { ...Session, messages: newMessages };
        }
        return Session;
      })
    );
  };

  const activeSession = Sessions.find((c) => c.id === sessionId);

  return (
    <div className="flex h-full">
      <canvas ref={canvasRef} style={{ display: "none" }} />
      <video ref={videoRef} autoPlay style={{ display: "none" }} muted />

      {/* Sidebar */}
      <div className="w-64 bg-gray-200 p-4 space-y-2">
        {capturing ? (
          <>
            <button
              onClick={() => setPaused((prev) => !prev)}
              className="px-4 py-2 rounded bg-yellow-500 text-white w-full"
            >
              {paused ? "再開" : "一時停止"}
            </button>
            <button
              onClick={handleStopCapture}
              className="px-4 py-2 rounded bg-red-500 text-white w-full"
            >
              停止
            </button>
          </>
        ) : (
          <>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleSessionSession}
            >
              記録の振り返り
            </button>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleStartCapture}
            >
              記録を開始
            </button>
          </>
        )}

        <SessionSidebar
          sessions={sessions}
          activeSessionId={sessionId || ""}
          setActiveSessionId={(id) => setActiveSessionId(id)}
        />
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {activeSession ? (
          <SessionWindow
            onAddMessage={handleAddMessage}
            Session={activeSession}
          />
        ) : (
          <div className="flex-1 flex justify-center items-center">
            <p className="text-gray-500">
              チャットを選択、または作成してください
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
"use client";

import { Session } from "@/types";

interface SessionSidebarProps {
  sessions: Session[]; // or adapt if your Session type is different
  activeSessionId: string;
  setActiveSessionId: (id: string) => void;
}

/**
 * A simple sidebar listing session objects.
 */
export default function SessionSidebar({
  sessions,
  activeSessionId,
  setActiveSessionId,
}: SessionSidebarProps) {
  return (
    <div>
      {sessions.map((session) => (
        <div
          key={session.id}
          onClick={() => setActiveSessionId(session.id)}
          className={`p-2 mb-2 cursor-pointer rounded ${
            session.id === activeSessionId ? "bg-blue-300" : "bg-white"
          }`}
        >
          <div className="text-sm font-bold">{session.id}</div>
          <div className="text-xs text-gray-600">
            {session.createdAt?.toString() ?? ""}
          </div>
        </div>
      ))}
    </div>
  );
}
"use client";

import { Thread } from "@/types";
import { useState } from "react";

interface SessionWindowProps {
  onAddMessage: (prompt: string) => void;
  threads: Thread[]; // Active Session object
}

/**
 * Displays the current Session's messages and an input for the user to ask questions.
 */
export default function SessionWindow({
  onAddMessage,
  threads,
}: SessionWindowProps) {
  const [userInput, setUserInput] = useState("");

  const handleSend = async () => {
    if (!userInput.trim()) return;
    onAddMessage(userInput.trim());
    setUserInput("");
  };

  return (
    <div className="flex flex-col flex-1 p-4">
      {/* Messages */}
      <div className="flex-1 overflow-auto mb-4 border p-2">
        {threads.map((thread: Thread, i: number) => (
          <div key={i} className="mb-2">
            <div
              className={
                thread.role === "user" ? "text-blue-600" : "text-green-600"
              }
            >
              {thread.role === "user" ? "You" : "AI"}
            </div>
            <div>{thread.content[0].text}</div>
          </div>
        ))}
      </div>

      {/* Input Form */}
      <div className="flex">
        <input
          type="text"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              handleSend();
            }
          }}
          className="border flex-1 px-2 py-1"
          placeholder="質問を入力..."
        />
        <button
          onClick={handleSend}
          className="bg-blue-500 text-white px-4 py-1 ml-2 rounded"
        >
          送信
        </button>
      </div>
    </div>
  );
}
"use client";

import { useEffect, useState } from "react";
import { onAuthStateChanged, User } from "firebase/auth";
import { useRouter } from "next/navigation";

import { auth } from "@/lib/firebase";
import { getSessions } from "@/lib/firestore";
import ClientHome from "./components/SessionHome";

/**
 * Main dashboard page: checks Firebase auth state;
 * if no user, redirects to "/login".
 */
export default function DashboardPage() {
  const router = useRouter();
  const [user, setUser] = useState<User | null>(null);
  const [sessions, setSessions] = useState<
    { sessionId: string; role: string; date: string; reply: string }[]
  >([]);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (!firebaseUser) {
        router.push("/login");
        return;
      }

      setUser(firebaseUser);
      const fetchedSessions = await getSessions(firebaseUser.uid);
      setSessions(fetchedSessions);
    });
    return () => unsubscribe();
  }, [router]);

  if (!user) {
    return (
      <div className="h-screen flex items-center justify-center">
        Loading...
      </div>
    );
  }

  return (
    <main className="h-screen">
      <ClientHome sessions={sessions} uid={user.uid} />
    </main>
  );
}
import { db } from "@/utils/clientApp";
import {
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  setDoc,
  Timestamp,
} from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

export interface MySessionState {
  date: string;
  reply: string;
}

// user/uid/record/uuid

export function createLocalSessionStore(
  userId: string
): SessionStore<MySessionState> {
  return {
    async get(
      sessionId: string
    ): Promise<SessionData<MySessionState> | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) return undefined;
      return docSnap.data() as SessionData<MySessionState>;
    },
    async save(
      sessionId: string,
      sessionData: SessionData<MySessionState>
    ): Promise<void> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      await setDoc(docRef, sessionData);
    },
  };
}

export const getSessions = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data() as {
      date: string;
      reply: string;
    };
    return {
      sessionId: doc.id,
      role: "user",
      date: date,
      reply,
    };
  });
};

export const getRecord = async (userId: string, recordId: string) => {
  // コレクションパスを"user/{uid}/record"に変更
  const docRef = doc(collection(db, "user", userId, "record"), recordId);
  const docSnap = await getDoc(docRef);
  if (!docSnap.exists) {
    return null;
  }
  const { date, reply } = docSnap.data() as { date: Timestamp; reply: string };
  return {
    role: "user",
    date: date,
    reply,
  };
};

export const addRecord = async (
  userId: string,
  data: { date: string; reply: string }
) => {
  const docRef = collection(db, "user", userId, "record");
  await addDoc(docRef, data);
};

export const addUser = async ({
  uid,
  displayName,
  email,
  photoURL,
}: {
  uid: string;
  displayName: string;
  email: string;
  photoURL: string;
}) => {
  const docRef = doc(db, "user", uid);
  await setDoc(docRef, {
    displayName,
    email,
    photoURL,
  });
};

export const getReords = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data();
    return {
      date: date,
      reply,
    };
  });
};
import { db } from "@/lib/firebase";
import {
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  setDoc,
  Timestamp,
} from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

export interface MySessionState {
  date: string;
  reply: string;
}

// user/uid/record/uuid

export function createLocalSessionStore(
  userId: string
): SessionStore<MySessionState> {
  return {
    async get(
      sessionId: string
    ): Promise<SessionData<MySessionState> | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) return undefined;
      return docSnap.data() as SessionData<MySessionState>;
    },
    async save(
      sessionId: string,
      sessionData: SessionData<MySessionState>
    ): Promise<void> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      await setDoc(docRef, sessionData);
    },
  };
}

export const getSessions = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data() as {
      date: string;
      reply: string;
    };
    return {
      sessionId: doc.id,
      role: "user",
      date: date,
      reply,
    };
  });
};

export const getRecord = async (userId: string, recordId: string) => {
  // コレクションパスを"user/{uid}/record"に変更
  const docRef = doc(collection(db, "user", userId, "record"), recordId);
  const docSnap = await getDoc(docRef);
  if (!docSnap.exists) {
    return null;
  }
  const { date, reply } = docSnap.data() as { date: Timestamp; reply: string };
  return {
    role: "user",
    date: date,
    reply,
  };
};

export const addRecord = async (
  userId: string,
  data: { date: string; reply: string }
) => {
  const docRef = collection(db, "user", userId, "record");
  await addDoc(docRef, data);
};

export const addUser = async ({
  uid,
  displayName,
  email,
  photoURL,
}: {
  uid: string;
  displayName: string;
  email: string;
  photoURL: string;
}) => {
  const docRef = doc(db, "user", uid);
  await setDoc(docRef, {
    displayName,
    email,
    photoURL,
  });
};

export const getReords = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data();
    return {
      date: date,
      reply,
    };
  });
};
// app/aiConfig.ts
import vertexAI, { gemini15Pro } from "@genkit-ai/vertexai";
import { genkit } from "genkit";

export const ai = genkit({
  plugins: [vertexAI()],
  model: gemini15Pro,
});
import { initializeApp, initializeServerApp } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";
import { initializeFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import { getGenerativeModel, getVertexAI } from "firebase/vertexai";

// .env.localなどから読み込むことを推奨
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};
// サーバーサイドでのみ利用する場合は以下のようにする
let app;
if (typeof window === "undefined") {
  app = initializeServerApp(firebaseConfig, {});
}
// アプリ初期化
app = initializeApp(firebaseConfig);
export const storage = getStorage(app);
export const vertexAI = getVertexAI(app);
export const db = initializeFirestore(app, { ignoreUndefinedProperties: true });

export const auth = getAuth();
export const googleAuthProvider = new GoogleAuthProvider();
export const model = getGenerativeModel(vertexAI, {
  model: "gemini-1.5-flash",
});
import "server-only";

import { db } from "@/lib/firebase";
import { collection, doc, getDoc, setDoc } from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

/**
 * セッションで保持したいカスタム情報を定義
 * メッセージ履歴以外にも、ユーザー名・フラグなど何でも追加可能
 */
export interface MySessionState {
  date: string;
  reply: string;
}

export function createLocalSessionStore(userId: string): SessionStore {
  return {
    async get(sessionId: string): Promise<SessionData | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) {
        return undefined;
      }
      return docSnap.data() as SessionData;
    },

    async save(sessionId: string, sessionData: SessionData): Promise<void> {
      console.log("🚀 ~ save ~ sessionData:", sessionData);
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      setDoc(docRef, sessionData);
    },
  };
}
export function computeFrame(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData {
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Canvas context not found");
  }

  // video要素のサイズとcanvasのサイズを同じにする
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // 現在のフレームをcanvasに描画
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // そのままImageDataを取得
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}
export class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500
  ) {
    super(message);
    this.name = "AppError";
  }
}

export const handleApiError = (error: unknown) => {
  console.error("API Error:", error);

  if (error instanceof AppError) {
    return { success: false, error: error.message, code: error.code };
  }

  return {
    success: false,
    error: "An unexpected error occurred",
    code: "INTERNAL_ERROR",
  };
};
