export interface User {
  displayName: string;
  email: string;
  photoURL: string;
}

export interface Session {
  id: string;
  threads: {
    main: Thread[];
  };
}

export interface Thread {
  content: [{ text: string }];
  role: "user" | "model" | "system";
  metadata: { preamble: boolean };
}

export interface Record {
  date: string;
  reply: string;
}
"use client";

import pixelmatch from "pixelmatch";
import { useCallback, useEffect, useRef, useState } from "react";

import { Chat } from "@/types";
import ChatSidebar from "./ChatSidebar";
import ChatWindow from "./ChatWindow";
// import { chatWithAI } from "@/app/actions";
import { postImage, postMessage } from "@/app/actions";
import { addRecord, createLocalSessionStore } from "@/utils/firestore";

const CAPTURE_CONFIG = {
  THRESHOLD: 0.1,
  MIN_DIFF_PERCENTAGE: 0.01,
} as const;

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
function getCanvasImageData(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData | null {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: ãƒ¡ãƒ‡ã‚£ã‚¢ãƒˆãƒ©ãƒƒã‚¯ã‚’åœæ­¢
function stopMediaTracks(video: HTMLVideoElement) {
  if (video.srcObject instanceof MediaStream) {
    video.srcObject.getTracks().forEach((track) => track.stop());
    video.srcObject = null;
  }
}

export default function ClientHome({
  sessions,
  uid,
}: {
  sessions: { date: string }[];
  uid: string;
}) {
  const [sessionId, setActiveChatId] = useState<string>();
  const [chats, setChats] = useState<Chat[]>([]);
  const [capturedImages, setCapturedImages] = useState<string[]>([]);

  const [capturing, setCapturing] = useState(false);
  const [paused, setPaused] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const previousImageDataRef = useRef<ImageData | null>(null);
  const store = createLocalSessionStore(uid);
  console.log("ğŸš€ ~ store:", store);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      handleStopCapture();
    };
  }, []);

  /**
   * Compare two ImageData objects and check if there's a significant difference
   */
  const checkSignificantDiff = (
    oldData: ImageData | null,
    newData: ImageData
  ): boolean => {
    if (!oldData) return true;
    if (oldData.width !== newData.width || oldData.height !== newData.height)
      return true;

    const { width, height } = newData;
    const diffOutput = new Uint8Array(width * height * 4);
    const numDiffPixels = pixelmatch(
      oldData.data,
      newData.data,
      diffOutput,
      width,
      height,
      {
        threshold: CAPTURE_CONFIG.THRESHOLD,
        includeAA: true,
        alpha: 0.1,
        diffColor: [255, 0, 0],
      }
    );

    const totalPixels = width * height;
    const diffRatio = numDiffPixels / totalPixels;

    return diffRatio >= CAPTURE_CONFIG.MIN_DIFF_PERCENTAGE;
  };

  /**
   * Capture a single screenshot and post if there's a significant difference
   */
  const captureScreenshot = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      console.log("Video not ready yet...");
      return;
    }
    const newImageData = getCanvasImageData(video, canvas);
    if (!newImageData) return;

    if (checkSignificantDiff(previousImageDataRef.current, newImageData)) {
      const image = canvas.toDataURL("image/png");
      setCapturedImages((prev) => [...prev, image]);
      const result = await postImage({ image });
      console.log("Image posted:", result.reply);
      await addRecord(uid, {
        date: result.date.toISOString(),
        reply: result.reply,
      });
    } else {
      console.log("No significant difference detected. Skipping.");
    }
    previousImageDataRef.current = newImageData;
  }, [uid]);

  /**
   * Start repeated capture using setInterval
   */
  useEffect(() => {
    if (!capturing || !videoRef.current) return;

    const intervalId = setInterval(() => {
      if (paused) {
        console.log("Capture paused.");
        return;
      }
      captureScreenshot();
    }, 1000);

    return () => clearInterval(intervalId);
  }, [capturing, paused, captureScreenshot]);

  /**
   * Handle start capturing
   */
  const handleStartCapture = async () => {
    if (capturing) return;

    try {
      console.log("Requesting display media...");
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
      });

      // Reset before capturing
      setCapturedImages([]);
      previousImageDataRef.current = null;

      if (!videoRef.current) throw new Error("Video element not found");
      videoRef.current.srcObject = stream;
      await videoRef.current.play();

      setCapturing(true);
      setPaused(false);
    } catch (err) {
      console.error("Error starting capture:", err);
      alert("ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  };

  const handleSessionChat = async () => {
    const newChat: Chat = {
      id: sessionId,
      messages: [],
    };
    setChats((prev) => [...prev, newChat]);
  };

  /**
   * Handle stop capturing
   */
  const handleStopCapture = async () => {
    console.log("Stopping capture...");
    setCapturing(false);
    setPaused(false);
    if (videoRef.current) {
      stopMediaTracks(videoRef.current);
    }
  };

  /**
   * Add a new message to a specific chat
   */
  const handleAddMessage = async (prompt: string) => {
    const response = await postMessage({
      uid,
      sessionId: sessionId,
      prompt,
    });
    console.log("ğŸš€ ~ handleAddMessage ~ response:", response);
    setChats((prevChats) =>
      prevChats.map((chat) => {
        if (chat.id === sessionId) {
          // return { ...chat, messages: [...chat.messages, msg] };
        }
        return chat;
      })
    );
  };

  /**
   * Identify the active chat object
   */
  const activeChat = chats.find((c) => c.id === sessionId);

  return (
    <div className="flex h-full">
      <canvas ref={canvasRef} style={{ display: "none" }} />
      <video ref={videoRef} autoPlay style={{ display: "none" }} muted />

      {/* Sidebar */}
      <div className="w-64 bg-gray-200 p-4 space-y-2">
        {capturing ? (
          <>
            <button
              onClick={() => setPaused((prev) => !prev)}
              className="px-4 py-2 rounded bg-yellow-500 text-white w-full"
            >
              {paused ? "å†é–‹" : "ä¸€æ™‚åœæ­¢"}
            </button>
            <button
              onClick={handleStopCapture}
              className="px-4 py-2 rounded bg-red-500 text-white w-full"
            >
              åœæ­¢
            </button>
          </>
        ) : (
          <>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleSessionChat}
            >
              è¨˜éŒ²ã®æŒ¯ã‚Šè¿”ã‚Š
            </button>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleStartCapture}
            >
              è¨˜éŒ²ã‚’é–‹å§‹
            </button>
          </>
        )}

        <ChatSidebar
          sessions={sessions}
          sessionId={sessionId}
          setActiveChatId={setActiveChatId}
        />
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {activeChat ? (
          <ChatWindow onAddMessage={handleAddMessage} />
        ) : (
          <div className="flex-1 flex justify-center items-center">
            <p className="text-gray-500">
              ãƒãƒ£ãƒƒãƒˆã‚’é¸æŠã€ã¾ãŸã¯ä½œæˆã—ã¦ãã ã•ã„
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
"use client";

import { useState } from "react";

interface Message {
  role: "user" | "ai";
  content: string;
  timestamp: string;
}

interface ChatWindowProps {
  onAddMessage: (prompt: string) => void;
}

// interface HistoryMessage {
//   role: "user" | "ai";
//   parts: { text: string }[];
// }

export default function ChatWindow({ onAddMessage }: ChatWindowProps) {
  const [userInput, setUserInput] = useState("");
  // const [chatHistory, setChatHistory] = useState<HistoryMessage[]>([]);

  const handleSend = async () => {
    if (!userInput.trim()) return;
    onAddMessage(userInput.trim());

    try {
      // const res = await fetch("/api/askQuestion", {
      //   method: "POST",
      //   headers: { "Content-Type": "application/json" },
      //   body: JSON.stringify({ chatId: chat.id, question: userInput }),
      // });
      // const data = await res.json();
      // const aiMsg: Message = {
      //   role: "ai",
      //   content: data.answer,
      //   timestamp: new Date().toISOString(),
      // };
      // onAddMessage(chat.id, aiMsg);
      // if (data.history) {
      //   setChatHistory(data.history);
      // }
    } catch (error) {
      console.error("Error in askQuestion:", error);
    }

    setUserInput("");
  };

  return (
    <div className="flex flex-col flex-1 p-4">
      {/* Messages */}
      <div className="flex-1 overflow-auto mb-4 border p-2">
        {/* {chat.messages.map((msg, i) => (
          <div key={i} className="mb-2">
            <div
              className={
                msg.role === "user" ? "text-blue-600" : "text-green-600"
              }
            >
              {msg.role === "user" ? "You" : "AI"}
            </div>
            <div>{msg.content}</div>
          </div>
        ))} */}

        {/* {chatHistory.map((msg, i) => (
          <div key={`history-${i}`} className="mb-2 text-gray-600">
            <div>{msg.role === "user" ? "You" : "AI"} (å±¥æ­´)</div>
            <div>{msg.parts[0]?.text || ""}</div>
          </div>
        ))} */}
      </div>

      {/* Input Form */}
      <div className="flex">
        <input
          type="text"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") handleSend();
          }}
          className="border flex-1 px-2 py-1"
          placeholder="è³ªå•ã‚’å…¥åŠ›..."
        />
        <button
          onClick={handleSend}
          className="bg-blue-500 text-white px-4 py-1 ml-2 rounded"
        >
          é€ä¿¡
        </button>
      </div>
    </div>
  );
}
"use client";

import { Session } from "@/types";

interface ChatSidebarProps {
  sessions: Session[];
  activeChatId: string | null;
  setActiveChatId: (id: string) => void;
}

export default function ChatSidebar({
  sessions,
  activeChatId,
  setActiveChatId,
}: ChatSidebarProps) {
  return (
    <div>
      {sessions.map((session, index) => (
        <div
          key={index}
          onClick={() => setActiveChatId(session.id)}
          className={`p-2 mb-2 cursor-pointer rounded ${
            session.id === activeChatId ? "bg-blue-300" : "bg-white"
          }`}
        >
          <div className="text-sm font-bold">
            sss
            {/* {session.createdAt.toISOString()} */}
          </div>
        </div>
      ))}
    </div>
  );
}
"use server";

import { ai } from "@/utils/aiConfig";
import { createLocalSessionStore } from "@/utils/localSessionStore";

import { getReords } from "@/utils/firestore";

export async function postImage({ image }: { image: string }) {
  const now = new Date();

  // 4) ãƒãƒ£ãƒƒãƒˆã‚’é€ä¿¡
  const chat = ai.chat();
  const prompt = `[æŒ‡ç¤º]
ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ·»ä»˜ã—ã¾ã™ã€‚

ã“ã‚Œã‚‰ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã«å†™ã£ã¦ã„ã‚‹æƒ…å ±ã‚’ã™ã¹ã¦æŠ½å‡ºã—ã€ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¦ã€äº‹å®Ÿã«åŸºã¥ã„ãŸè©³ç´°ãªãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

1. å„ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã«å†™ã£ã¦ã„ã‚‹æƒ…å ±ã‚’ç¶²ç¾…çš„ã«è¨˜è¿°ã™ã‚‹ã€‚
2. æƒ…å ±æºï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã‚’æ˜è¨˜ã™ã‚‹ã€‚
3. ç•°ãªã‚‹ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã«åŒä¸€ã®æƒ…å ±ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€é‡è¤‡ã‚’é¿ã‘ã¦ç°¡æ½”ã«ã¾ã¨ã‚ã‚‹ã€‚
4. æƒ…å ±ãŒçŸ›ç›¾ã™ã‚‹å ´åˆã¯ã€ãã‚Œãã‚Œã®æƒ…å ±ã‚’ä½µè¨˜ã—ã€çŸ›ç›¾ç‚¹ã‚’æŒ‡æ‘˜ã™ã‚‹ã€‚
5. å¿…è¦ã«å¿œã˜ã¦ã€æƒ…å ±ã®èƒŒæ™¯ã‚„æ„å‘³åˆã„ã‚’è€ƒå¯Ÿã™ã‚‹ã€‚
6. æ©Ÿå¯†äº‹é …ã‚„å€‹äººæƒ…å ±ãŒå«ã¾ã‚Œã‚‹å ´åˆã¯ã€é©åˆ‡ã«ä¼ã›ã‚‹ã€‚

  æ’®å½±æ—¥æ™‚: ${now.toLocaleDateString()}
  `.trim();

  const response = await chat.send([
    {
      media: {
        contentType: "image/png",
        url: image,
      },
    },
    { text: prompt },
  ]);

  return {
    reply: response.text,
    date: now,
  };
}

async function getSession(sessionId: string | undefined, uid: string) {
  const store = createLocalSessionStore(uid);
  if (sessionId) {
    const session = await ai.loadSession(sessionId, { store });
    return session;
  } else {
    const session = ai.createSession({
      store,
    });
    return session;
  }
}

async function getAIChat(sessionId: string | undefined, uid: string) {
  const records = await getReords(uid);
  const session = await getSession(sessionId, uid);
  if (sessionId) {
    return session.chat();
  } else {
    return session.chat({
      system: `ç§ã®éå»ã®è¨˜éŒ²ã§ã™ã€‚${JSON.stringify(records)}`,
    });
  }
}

export async function postMessage({
  uid,
  sessionId,
  prompt,
}: {
  uid: string;
  sessionId: string | undefined;
  prompt: string;
}) {
  const now = new Date();
  // 4) ãƒãƒ£ãƒƒãƒˆã‚’é€ä¿¡
  const session = await getSession(sessionId, uid);
  const sessionChat = await getAIChat(sessionId, uid);

  const response = await sessionChat.send(
    `ã‚ãªãŸã¯ã€éå»ã®æ™‚ç³»åˆ—ã®æ—¥è¨˜ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«ç­”ãˆã‚‹AIã§ã™ã€‚

## æ—¥è¨˜ãƒ‡ãƒ¼ã‚¿
sessionæƒ…å ±ã‚’ã‚‚ã¨ã«

## æŒ‡ç¤º

1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®è³ªå•ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
2. è³ªå•å†…å®¹ã‚’ç†è§£ã—ã€æ—¥è¨˜ãƒ‡ãƒ¼ã‚¿ã®ä¸­ã‹ã‚‰é–¢é€£ã™ã‚‹æƒ…å ±ã‚’æ¤œç´¢ã—ã¾ã™ã€‚
3. é–¢é€£ã™ã‚‹æƒ…å ±ã«åŸºã¥ã„ã¦ã€è³ªå•ã«å¯¾ã™ã‚‹å›ç­”ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
4. å›ç­”ã¯ã€äº‹å®Ÿã«åŸºã¥ã„ãŸæ­£ç¢ºãªã‚‚ã®ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
5. å›ç­”ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦åˆ†ã‹ã‚Šã‚„ã™ãã€ä¸å¯§ãªè¨€è‘‰é£ã„ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
6. å›ç­”ã®ä¸­ã§ã€æ—¥è¨˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã®å¼•ç”¨ã‚’é©åˆ‡ã«è¡Œã†ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
7. è³ªå•å†…å®¹ã«ã‚ˆã£ã¦ã¯ã€è¤‡æ•°ã®æ—¥è¨˜ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
8. è³ªå•å†…å®¹ã«ã‚ˆã£ã¦ã¯ã€å›ç­”ãŒå›°é›£ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚ãã®å ´åˆã¯ã€ã€Œã“ã®è³ªå•ã«ã¯ãŠç­”ãˆã§ãã¾ã›ã‚“ã€ã¨å›ç­”ã—ã¦ãã ã•ã„ã€‚

## ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®è³ªå•
${prompt}
  `.trim()
  );

  return {
    reply: response.text,
    sessionId: session.id,
    date: now,
  };
}
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "AI Recorder",
  description: "Manage and analyze records using AI",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
"use client";

import { auth, googleAuthProvider } from "@/lib/firebase";
import { addUser } from "@/lib/firestore";
import { onAuthStateChanged, signInWithPopup } from "firebase/auth";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function JP() {
  const router = useRouter();

  // ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ãªã‚‰ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã™ã‚‹
  useEffect(() => {
    return onAuthStateChanged(auth, (user) => {
      if (user) {
        router.push("/");
      }
    });
  }, [router]);

  const signInWithGoogle = async () => {
    try {
      const { user } = await signInWithPopup(auth, googleAuthProvider);
      await addUser({
        uid: user.uid,
        email: user.email || "",
        displayName: user.displayName || "",
        photoURL: user.photoURL || "",
      });
    } catch (error) {
      console.error("Error during Google login", error);
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center p-4">
      <section className="mb-8 text-center">
        <h1 className="text-4xl font-bold mb-4">Welcome to AI Record</h1>
        <p className="text-lg">
          æ©Ÿèƒ½ç´¹ä»‹: å½“ã‚µãƒ¼ãƒ“ã‚¹ã¯AIã‚’æ´»ç”¨ã—ãŸè¨˜éŒ²ç®¡ç†ã¨åˆ†æã‚’æä¾›ã—ã¾ã™ã€‚
        </p>
      </section>
      <section className="w-full max-w-md">
        <form className="flex flex-col space-y-4">
          <button
            type="button"
            className="bg-red-500 text-white py-2"
            onClick={signInWithGoogle}
          >
            Google Login
          </button>
        </form>
      </section>
    </div>
  );
}
"use client";

import pixelmatch from "pixelmatch";
import { useCallback, useEffect, useRef, useState } from "react";

import { postImage, postMessage } from "@/app/actions";
import { addRecord } from "@/lib/firestore";
import { createLocalSessionStore } from "@/lib/localSessionStore";
import { Session } from "@/types";

import SessionSidebar from "./SessionSidebar";
import SessionWindow from "./SessionWindow";

interface ClientHomeProps {
  sessions: { date: string }[];
  uid: string;
}

/** Configuration constants */
const CAPTURE_CONFIG = {
  THRESHOLD: 0.1,
  MIN_DIFF_PERCENTAGE: 0.01,
} as const;

/**
 * Helper: draw current frame from video to canvas and retrieve ImageData.
 */
function getCanvasImageData(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData | null {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}

/**
 * Helper: stop all media tracks in the given video element.
 */
function stopMediaTracks(video: HTMLVideoElement) {
  if (video.srcObject instanceof MediaStream) {
    video.srcObject.getTracks().forEach((track) => track.stop());
    video.srcObject = null;
  }
}

/**
 * Main component that handles:
 * 1) Screen capture & difference checking.
 * 2) Session session creation and message handling.
 */
export default function ClientHome({ sessions, uid }: ClientHomeProps) {
  const [sessionId, setActiveSessionId] = useState<string>();
  const [Sessions, setSessions] = useState<Session[]>([]);
  const [capturedImages, setCapturedImages] = useState<string[]>([]);
  const [capturing, setCapturing] = useState(false);
  const [paused, setPaused] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const previousImageDataRef = useRef<ImageData | null>(null);

  // Example usage of a local session store if needed:
  const store = createLocalSessionStore(uid);

  /**
   * Cleanup on unmount: stop capture if still running.
   */
  useEffect(() => {
    return () => {
      handleStopCapture();
    };
  }, []);

  /**
   * Compare two ImageData objects and check if there's a significant difference.
   */
  const checkSignificantDiff = (
    oldData: ImageData | null,
    newData: ImageData
  ): boolean => {
    if (!oldData) return true;
    if (oldData.width !== newData.width || oldData.height !== newData.height) {
      return true;
    }

    const { width, height } = newData;
    const diffOutput = new Uint8Array(width * height * 4);
    const numDiffPixels = pixelmatch(
      oldData.data,
      newData.data,
      diffOutput,
      width,
      height,
      {
        threshold: CAPTURE_CONFIG.THRESHOLD,
        includeAA: true,
        alpha: 0.1,
        diffColor: [255, 0, 0],
      }
    );

    const totalPixels = width * height;
    const diffRatio = numDiffPixels / totalPixels;
    return diffRatio >= CAPTURE_CONFIG.MIN_DIFF_PERCENTAGE;
  };

  /**
   * Capture a single screenshot and, if there is a significant difference,
   * send it to the server for AI-based extraction.
   */
  const captureScreenshot = useCallback(async () => {
    if (!videoRef.current || !canvasRef.current) return;
    const video = videoRef.current;
    const canvas = canvasRef.current;

    if (video.videoWidth === 0 || video.videoHeight === 0) {
      console.log("Video not ready yet...");
      return;
    }

    const newImageData = getCanvasImageData(video, canvas);
    if (!newImageData) return;

    if (checkSignificantDiff(previousImageDataRef.current, newImageData)) {
      const image = canvas.toDataURL("image/png");
      setCapturedImages((prev) => [...prev, image]);

      const result = await postImage({ image });
      await addRecord(uid, {
        date: result.date.toISOString(),
        reply: result.reply,
      });
    }
    previousImageDataRef.current = newImageData;
  }, [uid]);

  /**
   * Start repeated capture at a fixed interval.
   */
  useEffect(() => {
    if (!capturing || !videoRef.current) return;

    const intervalId = setInterval(() => {
      if (!paused) {
        void captureScreenshot();
      }
    }, 1000);

    return () => clearInterval(intervalId);
  }, [capturing, paused, captureScreenshot]);

  /**
   * Handle the start of a screen capture.
   */
  const handleStartCapture = async () => {
    if (capturing) return;
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
      });
      setCapturedImages([]);
      previousImageDataRef.current = null;

      if (!videoRef.current) {
        throw new Error("Video element not found");
      }
      videoRef.current.srcObject = stream;
      await videoRef.current.play();

      setCapturing(true);
      setPaused(false);
    } catch (err) {
      console.error("Error starting capture:", err);
      alert("ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  };

  /**
   * Create a new blank Session or open "review" if there's no sessionId.
   */
  const handleSessionSession = () => {
    const newSession: Session = {
      id: sessionId || "new-session",
      messages: [],
    };
    setSessions((prev) => [...prev, newSession]);
  };

  /**
   * Stop capturing entirely.
   */
  const handleStopCapture = () => {
    setCapturing(false);
    setPaused(false);

    if (videoRef.current) {
      stopMediaTracks(videoRef.current);
    }
  };

  /**
   * Send a new user message to the AI.
   */
  const handleAddMessage = async (prompt: string) => {
    const response = await postMessage({
      uid,
      sessionId,
      prompt,
    });
    // Example: add to local Session state if needed
    setSessions((prevSessions) =>
      prevSessions.map((Session) => {
        if (Session.id === sessionId) {
          const newMessages = [
            ...Session.messages,
            { role: "user", content: prompt },
            { role: "ai", content: response.reply },
          ];
          return { ...Session, messages: newMessages };
        }
        return Session;
      })
    );
  };

  const activeSession = Sessions.find((c) => c.id === sessionId);

  return (
    <div className="flex h-full">
      <canvas ref={canvasRef} style={{ display: "none" }} />
      <video ref={videoRef} autoPlay style={{ display: "none" }} muted />

      {/* Sidebar */}
      <div className="w-64 bg-gray-200 p-4 space-y-2">
        {capturing ? (
          <>
            <button
              onClick={() => setPaused((prev) => !prev)}
              className="px-4 py-2 rounded bg-yellow-500 text-white w-full"
            >
              {paused ? "å†é–‹" : "ä¸€æ™‚åœæ­¢"}
            </button>
            <button
              onClick={handleStopCapture}
              className="px-4 py-2 rounded bg-red-500 text-white w-full"
            >
              åœæ­¢
            </button>
          </>
        ) : (
          <>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleSessionSession}
            >
              è¨˜éŒ²ã®æŒ¯ã‚Šè¿”ã‚Š
            </button>
            <button
              className="bg-blue-500 text-white px-4 py-2 mb-4 rounded w-full"
              onClick={handleStartCapture}
            >
              è¨˜éŒ²ã‚’é–‹å§‹
            </button>
          </>
        )}

        <SessionSidebar
          sessions={sessions}
          activeSessionId={sessionId || ""}
          setActiveSessionId={(id) => setActiveSessionId(id)}
        />
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {activeSession ? (
          <SessionWindow
            onAddMessage={handleAddMessage}
            Session={activeSession}
          />
        ) : (
          <div className="flex-1 flex justify-center items-center">
            <p className="text-gray-500">
              ãƒãƒ£ãƒƒãƒˆã‚’é¸æŠã€ã¾ãŸã¯ä½œæˆã—ã¦ãã ã•ã„
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
"use client";

import { Session } from "@/types";

interface SessionSidebarProps {
  sessions: Session[]; // or adapt if your Session type is different
  activeSessionId: string;
  setActiveSessionId: (id: string) => void;
}

/**
 * A simple sidebar listing session objects.
 */
export default function SessionSidebar({
  sessions,
  activeSessionId,
  setActiveSessionId,
}: SessionSidebarProps) {
  return (
    <div>
      {sessions.map((session) => (
        <div
          key={session.id}
          onClick={() => setActiveSessionId(session.id)}
          className={`p-2 mb-2 cursor-pointer rounded ${
            session.id === activeSessionId ? "bg-blue-300" : "bg-white"
          }`}
        >
          <div className="text-sm font-bold">{session.id}</div>
          <div className="text-xs text-gray-600">
            {session.createdAt?.toString() ?? ""}
          </div>
        </div>
      ))}
    </div>
  );
}
"use client";

import { Thread } from "@/types";
import { useState } from "react";

interface SessionWindowProps {
  onAddMessage: (prompt: string) => void;
  threads: Thread[]; // Active Session object
}

/**
 * Displays the current Session's messages and an input for the user to ask questions.
 */
export default function SessionWindow({
  onAddMessage,
  threads,
}: SessionWindowProps) {
  const [userInput, setUserInput] = useState("");

  const handleSend = async () => {
    if (!userInput.trim()) return;
    onAddMessage(userInput.trim());
    setUserInput("");
  };

  return (
    <div className="flex flex-col flex-1 p-4">
      {/* Messages */}
      <div className="flex-1 overflow-auto mb-4 border p-2">
        {threads.map((thread: Thread, i: number) => (
          <div key={i} className="mb-2">
            <div
              className={
                thread.role === "user" ? "text-blue-600" : "text-green-600"
              }
            >
              {thread.role === "user" ? "You" : "AI"}
            </div>
            <div>{thread.content[0].text}</div>
          </div>
        ))}
      </div>

      {/* Input Form */}
      <div className="flex">
        <input
          type="text"
          value={userInput}
          onChange={(e) => setUserInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              handleSend();
            }
          }}
          className="border flex-1 px-2 py-1"
          placeholder="è³ªå•ã‚’å…¥åŠ›..."
        />
        <button
          onClick={handleSend}
          className="bg-blue-500 text-white px-4 py-1 ml-2 rounded"
        >
          é€ä¿¡
        </button>
      </div>
    </div>
  );
}
"use client";

import { useEffect, useState } from "react";
import { onAuthStateChanged, User } from "firebase/auth";
import { useRouter } from "next/navigation";

import { auth } from "@/lib/firebase";
import { getSessions } from "@/lib/firestore";
import ClientHome from "./components/SessionHome";

/**
 * Main dashboard page: checks Firebase auth state;
 * if no user, redirects to "/login".
 */
export default function DashboardPage() {
  const router = useRouter();
  const [user, setUser] = useState<User | null>(null);
  const [sessions, setSessions] = useState<
    { sessionId: string; role: string; date: string; reply: string }[]
  >([]);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (!firebaseUser) {
        router.push("/login");
        return;
      }

      setUser(firebaseUser);
      const fetchedSessions = await getSessions(firebaseUser.uid);
      setSessions(fetchedSessions);
    });
    return () => unsubscribe();
  }, [router]);

  if (!user) {
    return (
      <div className="h-screen flex items-center justify-center">
        Loading...
      </div>
    );
  }

  return (
    <main className="h-screen">
      <ClientHome sessions={sessions} uid={user.uid} />
    </main>
  );
}
import { db } from "@/utils/clientApp";
import {
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  setDoc,
  Timestamp,
} from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

export interface MySessionState {
  date: string;
  reply: string;
}

// user/uid/record/uuid

export function createLocalSessionStore(
  userId: string
): SessionStore<MySessionState> {
  return {
    async get(
      sessionId: string
    ): Promise<SessionData<MySessionState> | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) return undefined;
      return docSnap.data() as SessionData<MySessionState>;
    },
    async save(
      sessionId: string,
      sessionData: SessionData<MySessionState>
    ): Promise<void> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      await setDoc(docRef, sessionData);
    },
  };
}

export const getSessions = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data() as {
      date: string;
      reply: string;
    };
    return {
      sessionId: doc.id,
      role: "user",
      date: date,
      reply,
    };
  });
};

export const getRecord = async (userId: string, recordId: string) => {
  // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ã‚¹ã‚’"user/{uid}/record"ã«å¤‰æ›´
  const docRef = doc(collection(db, "user", userId, "record"), recordId);
  const docSnap = await getDoc(docRef);
  if (!docSnap.exists) {
    return null;
  }
  const { date, reply } = docSnap.data() as { date: Timestamp; reply: string };
  return {
    role: "user",
    date: date,
    reply,
  };
};

export const addRecord = async (
  userId: string,
  data: { date: string; reply: string }
) => {
  const docRef = collection(db, "user", userId, "record");
  await addDoc(docRef, data);
};

export const addUser = async ({
  uid,
  displayName,
  email,
  photoURL,
}: {
  uid: string;
  displayName: string;
  email: string;
  photoURL: string;
}) => {
  const docRef = doc(db, "user", uid);
  await setDoc(docRef, {
    displayName,
    email,
    photoURL,
  });
};

export const getReords = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data();
    return {
      date: date,
      reply,
    };
  });
};
import { db } from "@/lib/firebase";
import {
  addDoc,
  collection,
  doc,
  getDoc,
  getDocs,
  query,
  setDoc,
  Timestamp,
} from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

export interface MySessionState {
  date: string;
  reply: string;
}

// user/uid/record/uuid

export function createLocalSessionStore(
  userId: string
): SessionStore<MySessionState> {
  return {
    async get(
      sessionId: string
    ): Promise<SessionData<MySessionState> | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) return undefined;
      return docSnap.data() as SessionData<MySessionState>;
    },
    async save(
      sessionId: string,
      sessionData: SessionData<MySessionState>
    ): Promise<void> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      await setDoc(docRef, sessionData);
    },
  };
}

export const getSessions = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data() as {
      date: string;
      reply: string;
    };
    return {
      sessionId: doc.id,
      role: "user",
      date: date,
      reply,
    };
  });
};

export const getRecord = async (userId: string, recordId: string) => {
  // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ‘ã‚¹ã‚’"user/{uid}/record"ã«å¤‰æ›´
  const docRef = doc(collection(db, "user", userId, "record"), recordId);
  const docSnap = await getDoc(docRef);
  if (!docSnap.exists) {
    return null;
  }
  const { date, reply } = docSnap.data() as { date: Timestamp; reply: string };
  return {
    role: "user",
    date: date,
    reply,
  };
};

export const addRecord = async (
  userId: string,
  data: { date: string; reply: string }
) => {
  const docRef = collection(db, "user", userId, "record");
  await addDoc(docRef, data);
};

export const addUser = async ({
  uid,
  displayName,
  email,
  photoURL,
}: {
  uid: string;
  displayName: string;
  email: string;
  photoURL: string;
}) => {
  const docRef = doc(db, "user", uid);
  await setDoc(docRef, {
    displayName,
    email,
    photoURL,
  });
};

export const getReords = async (userId: string) => {
  const q = query(collection(db, "user", userId, "record"));
  const docSnap = await getDocs(q);
  if (docSnap.empty) {
    return [];
  }
  return docSnap.docs.map((doc) => {
    const { date, reply } = doc.data();
    return {
      date: date,
      reply,
    };
  });
};
// app/aiConfig.ts
import vertexAI, { gemini15Pro } from "@genkit-ai/vertexai";
import { genkit } from "genkit";

export const ai = genkit({
  plugins: [vertexAI()],
  model: gemini15Pro,
});
import { initializeApp, initializeServerApp } from "firebase/app";
import { getAuth, GoogleAuthProvider } from "firebase/auth";
import { initializeFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import { getGenerativeModel, getVertexAI } from "firebase/vertexai";

// .env.localãªã©ã‹ã‚‰èª­ã¿è¾¼ã‚€ã“ã¨ã‚’æ¨å¥¨
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,
};
// ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã®ã¿åˆ©ç”¨ã™ã‚‹å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹
let app;
if (typeof window === "undefined") {
  app = initializeServerApp(firebaseConfig, {});
}
// ã‚¢ãƒ—ãƒªåˆæœŸåŒ–
app = initializeApp(firebaseConfig);
export const storage = getStorage(app);
export const vertexAI = getVertexAI(app);
export const db = initializeFirestore(app, { ignoreUndefinedProperties: true });

export const auth = getAuth();
export const googleAuthProvider = new GoogleAuthProvider();
export const model = getGenerativeModel(vertexAI, {
  model: "gemini-1.5-flash",
});
import "server-only";

import { db } from "@/lib/firebase";
import { collection, doc, getDoc, setDoc } from "firebase/firestore";

import { SessionData, SessionStore } from "genkit";

/**
 * ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ä¿æŒã—ãŸã„ã‚«ã‚¹ã‚¿ãƒ æƒ…å ±ã‚’å®šç¾©
 * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ä»¥å¤–ã«ã‚‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åãƒ»ãƒ•ãƒ©ã‚°ãªã©ä½•ã§ã‚‚è¿½åŠ å¯èƒ½
 */
export interface MySessionState {
  date: string;
  reply: string;
}

export function createLocalSessionStore(userId: string): SessionStore {
  return {
    async get(sessionId: string): Promise<SessionData | undefined> {
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      const docSnap = await getDoc(docRef);
      if (!docSnap.exists) {
        return undefined;
      }
      return docSnap.data() as SessionData;
    },

    async save(sessionId: string, sessionData: SessionData): Promise<void> {
      console.log("ğŸš€ ~ save ~ sessionData:", sessionData);
      const docRef = doc(collection(db, "user", userId, "session"), sessionId);
      setDoc(docRef, sessionData);
    },
  };
}
export function computeFrame(
  video: HTMLVideoElement,
  canvas: HTMLCanvasElement
): ImageData {
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Canvas context not found");
  }

  // videoè¦ç´ ã®ã‚µã‚¤ã‚ºã¨canvasã®ã‚µã‚¤ã‚ºã‚’åŒã˜ã«ã™ã‚‹
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  // ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’canvasã«æç”»
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // ãã®ã¾ã¾ImageDataã‚’å–å¾—
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}
export class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500
  ) {
    super(message);
    this.name = "AppError";
  }
}

export const handleApiError = (error: unknown) => {
  console.error("API Error:", error);

  if (error instanceof AppError) {
    return { success: false, error: error.message, code: error.code };
  }

  return {
    success: false,
    error: "An unexpected error occurred",
    code: "INTERNAL_ERROR",
  };
};
